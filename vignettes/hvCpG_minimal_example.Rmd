---
title: "Minimal hvCpG detection example"
author: "Alice Balard"
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Minimal hvCpG Example}
%\VignetteEngine{knitr::rmarkdown}
%\VignetteEncoding{UTF-8}
---
  
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(
eval = TRUE,
message = FALSE,
warning = FALSE,
echo = TRUE,
fig.align = "center",
fig.width = 12, # base width in inches
fig.height = 6,
out.width = "100%" # make the figure scale to container width
)

library(devtools)
devtools::load_all()
library(hyperVarMeth)
```

## 1. Create a mock methylation dataset

```{r}
mock <- create_mock_hvCpG_data()
```

This creates a small mock dataset with a few CpGs, samples, and datasets for testing.

## 2. Prepare data

```{r}
prep <- prepData("mock", dirname(mock$metadata))
str(prep)
```

prep contains:

- metadata: sample and dataset information
- medsd_lambdas: dataset-level parameters
- cpg_names_all: all CpG names
- h5file: path to HDF5 methylation matrix

```{r}
library(rhdf5)
library(ggplot2)

metadata <- read.table(mock$metadata, header = TRUE, sep = "\t", stringsAsFactors = FALSE)
h5file <- mock$h5file

# Read methylation matrix from HDF5
mat <- h5read(h5file, "matrix")
rownames(mat) <- mock$cpg_names
colnames(mat) <- metadata$sample

# Compute per-CpG SD across samples
cpg_sd <- apply(mat, 1, sd, na.rm = TRUE)

# Melt matrix for plotting
mat_df <- reshape2::melt(mat, varnames = c("CpG", "Sample"), value.name = "Beta")
mat_df <- merge(mat_df, metadata, by.x = "Sample", by.y = "sample")

ggplot(mat_df, aes(x = Beta, group = dataset, fill = dataset)) +
  geom_histogram(binwidth = 0.05, color = "black") +
  facet_wrap(~ dataset, ncol = 2) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "none") +
  labs(title = "Beta-value distributions per dataset", x = "Beta", y = "Count")
```

## 3. Run hvCpG detection (batched + parallel)

```{r}
tmp_dir <- tempdir()

result <- runAndSave_fast(
  analysis = "mock",
  cpg_names_vec = prep$cpg_names_all,
  resultDir = tmp_dir,
  NCORES = 1,
  p0 = 0.9,
  p1 = 0.9,
  dataDir = dirname(mock$metadata),
  batch_size = 10, # smaller batch for mock
  skipsave = FALSE
)
```

This will compute the optimal alpha values for all CpGs in the mock dataset and save the result to tmp_dir.

## 4. Inspect Results

### Check the first few results
```{r}
head(result)
```
You should see a matrix of CpGs (rows) and their estimated alpha values.

```{r}
library(ggplot2)
ggplot(result, aes(x=alpha)) +
  geom_histogram() +
  theme_minimal(base_size = 14)

# Plot raw values for an extremely stable and an extremely variable CpGs:

sta <- rownames(result)[which(result %in% min(result))[1]]

idx_mid <- which.min(abs(result - 0.5))
mid <- rownames(result)[idx_mid]

var <- rownames(result)[which(result %in% max(result))[1]]

ggplot(mat_df[mat_df$CpG %in% sta,], aes(x=Sample, y = Beta))+
  geom_point(aes(col=dataset), size = 3)+
  theme_minimal(base_size = 14) +
  coord_cartesian(ylim = c(0,1))+
  ggtitle("a stable CpG")

ggplot(mat_df[mat_df$CpG %in% mid,], aes(x=Sample, y = Beta))+
  geom_point(aes(col=dataset), size = 3)+
  theme_minimal(base_size = 14) +
  coord_cartesian(ylim = c(0,1))+
  ggtitle("a variable CpG")

ggplot(mat_df[mat_df$CpG %in% var,], aes(x=Sample, y = Beta))+
  geom_point(aes(col=dataset), size = 3)+
  theme_minimal(base_size = 14)+
  coord_cartesian(ylim = c(0,1))+
  ggtitle("a hyper variable CpG")
```


### Confirm result file exists
```{r}
list.files(tmp_dir, pattern = "results_mock")
```


## Notes

For real datasets, increase batch_size and NCORES appropriately.

Use skipsave = TRUE if you do not want to write files to disk during testing.

This vignette demonstrates the minimal workflow using mock data to ensure everything runs before applying to large-scale datasets.

